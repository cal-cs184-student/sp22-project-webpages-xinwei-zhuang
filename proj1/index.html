<!DOCTYPE html>
<html>
<head>
<title>Page Title</title>

<script src="/js/mathjax/tex-chtml.js" id="MathJax-script" async></script>
<script type="text/javascript" src="LaTeXMathML.js">
  <script defer src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
(function () {
  var script = document.createElement('script');
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js';
  script.async = true;
  document.head.appendChild(script);
})();
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<script>
function openNav() {
  document.getElementById("mySidebar").style.width = "200px";
  document.getElementById("main").style.marginLeft = "200px";
}

function closeNav() {
  document.getElementById("mySidebar").style.width = "0";
  document.getElementById("main").style.marginLeft= "0";
}
</script>

<style>

code {
  font-family: 'Trebuchet MS', Helvetica, sans-serif;
  color: #336699;
  padding: 2px;
  font-size: 80%;
  line-height: 1.5;
}
.MathJax {
font-size: 1.2em;
}
.center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
html {
    margin:    0 auto;
    max-width: 1200px;
}
body {
  background-color: RGB(250,250,250);
  color: #303060;
  font-family: 'Trebuchet MS', Helvetica, sans-serif;
box-sizing: border-box;
  width: 100%; 
  padding: 20px;   
  margin: auto;
}
p.big {
  line-height: 1.5;
}
figure figcaption {
    text-align: center;
}
figure {
    display: block;
    margin: 0 1em 1em 0;
    vertical-align: middle;
    text-align: center;
    max-height: 80%;  
    max-width: 80%; 
    top: 0;  
    bottom: 0;  
    left: 0;  
    right: 0;  
    margin-left: auto;
    margin-right: auto ;
}
* {
  box-sizing: border-box;
}
.column {
  float: left;
  width: 33%;
  padding: 5px;
}

/* Clearfix (clear floats) */
.row::after {
  content: "";
  clear: both;
  display: table;
}

.main {
  vertical-align: middle;
  margin-left: 230px; /* Same as the width of the sidenav */
  padding: 0px 10px;
}
/* Clearfix (clear floats) */
.row::after {
  content: "";
  clear: both;
  display: table;
  position: relative;
}
.img {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.box {
  float: middle;
  width: 80%;
  padding: 20px;
}

.sidenav {
  height: 100%;
  width: 230px;
  position: fixed;
  z-index: 1;
  top: 50;
  left: 0;

  background-color: RGB(250,250,250);
  overflow-x: hidden;
  margin-top: 100px;
  transition: 0.5s;

}

.sidenav a.first {
  padding: 6px 8px 6px 10px;
  text-decoration: none;
  font-size: 20px;
  color: #303060;
  display: block;
  text-align: right;
}

.sidenav a.second {
  padding: 6px 8px 6px 70px;
  text-decoration: none;
  font-size: 15px;
  color: #303060;
  display: block;
  text-align: right;
}

.sidenav a.first:hover {
  font-size: 25px;
  font-weight: bold;
}
.sidenav a.second:hover {
  font-size: 17px;
  font-weight: bold;
}
.sidenav .closebtn {
  position: absolute;
  top: 0;
  right: 25px;
  font-size: 36px;
  margin-left: 50px;
}
.vl {
  border-left: 5px;
  height: 400px;
  width : 1px;
  position: absolute;
  left: 218.5px;
  top:  0 px;
  background-image: linear-gradient( transparent, #303060, transparent);
}
.matrix {
    position: relative;
}

.matrix:before, .matrix:after {
    content: "";
    position: absolute;
    top: 0;
    border: 1px solid #f1f1f1;
    width: 6px;
    height: 100%;
}
.matrix:before {
    left: -6px;
    border-right: 0px;
}
.matrix:after {
    right: -6px;
    border-left: 0px;
}
.matrix: td {
    padding: 5px;    
    text-align: center;
}



}


</style>

</head>
<body>
<div id="mySidebar" class="sidenav">
  <div class="vl"></div>
  <br><br><br>
  <atopic><a class= 'second' href="#1" >Part 1 <span>&#8729;</span></a></atopic>
  <atopic><a class= 'second' href="#2" >Part 2 <span>&#8729;</span></a></atopic>
  <atopic><a class= 'second' href="#3" >Part 3 <span>&#8729;</span></a></atopic>
  <atopic><a class= 'second' href="#4" >Part 4 <span>&#8729;</span></a></atopic>
  <atopic><a class= 'second' href="#5" >Part 5 <span>&#8729;</span></a></atopic>
  <atopic><a class= 'second' href="#6" >Part 6 <span>&#8729;</span></a></atopic>

</div>

<div class="main">
<br><br><br><br>
<h1>Project 1: Rasterizer</h1>

<p style="font-size:15px;">CS 284a Computer graphics & Imaging </p> 2022 Spring Kaleab Belete, Xinwei Zhuang</p>
Webpage: <a href="https://cal-cs184-student.github.io/sp22-project-webpages-xinwei-zhuang/proj1/index.html"> https://cal-cs184-student.github.io/sp22-project-webpages-xinwei-zhuang/proj1/index.html</a>

<hr>

<h2 id="1">Part 1: Drawing Single-Color Triangles</h2>
<b>Walk through how you rasterize triangles in your own words.</b><br><br>

The basic steps for this part are:<br><br>
1) Get truncated lower and upper bounds for looping through the image first using min or max functions on the set of xs and ys then using 0 for the lower bound, and hight/width for the upper bound.<br><br>
2) make a line test lambda function to check if a point (p0,p1) falls withn a given triangle<br><br>
3) loop through bounds and fill in points with the appropriate color in the appropriate position if they pass the line test<br><br>

<b>Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle.</b><br><br>
We only visit each point once and use truncated bounds so it is better than checking every point.<br><br>

<b>Show a png screenshot of basic/test4.svg with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</b><br><br>
<div class="row">
  <div class="column">
    <figure>
  <p><img src="image/part1_test4_1.png" style="width:300px">
    <figcaption>Test 4, 1 sample per pixel</figcaption>
</figure>
  </div>
</div>

<b>Extra credit</b> <br><br>
As explained above we use truncated bounds and with the truncated bounds we are able to get a time of: <br><br>
<table>
  <tr>
    <th>With</th>
    <th>Without</th>
  </tr>
  <tr>
    <td>It took 913 clicks or (0.000913 seconds). </td>
    <td>It took 12991 clicks or (0.012991 seconds).</td>
  </tr>
  <tr>
    <td>It took 492 clicks or (0.000492 seconds).</td>
    <td>It took 12986 clicks or (0.012986 seconds).</td>
  </tr>
  <tr>
    <td>It took 331 clicks or (0.000331 seconds).</td>
    <td>It took 12318 clicks or (0.012318 seconds).</td>
  </tr>
  <tr>
    <td>It took 802 clicks or (0.000802 seconds).</td>
    <td>It took 12372 clicks or (0.012372 seconds).</td>
  </tr>
  <tr>
    <td>It took 87 clicks or (0.000087 seconds). </td>
    <td>It took 12238 clicks or (0.012238 seconds).</td>
  </tr>
</table>



<br><br>
<h2 id="2">Part 2: Antialiasing by Supersampling </h2>
<b>Walk through your supersampling algorithm and data structures. Why is supersampling useful? What modifications did you make to the rasterization pipeline in the process? Explain how you used supersampling to antialias your triangles.</b><br><br>

Given a sample rate x the basic steps for this part are:<br><br>
1) We have a sample buffer which is a list of colors that we will resize beased on the the image size and sample rate <br><br>
2) the rasterization of triangles is done in like in part 1 with an added set of inner nested loops to handel assigning the colors to the resized frame buffer <br><br>
3) the color sampling is managed in the resolve to framebuffer method with a new innerloop that traverses in the range (1,sqrt(x)*(sqrt(x)) accumulating color values <br><br>

Supersampling is useful in things like antialising because it can take context (near by pixals) into account when rendering an image which helps with continuity and reduces the jaggies that zoomed in pictures have. <br><br>
Supersampling acts as a low pass filter antialising pictures and removing jaggies/sharp eges that are a result of a high frequancy input.  <br><br>

<b>Show png screenshots of basic/test4.svg with the default viewing parameters and sample rates 1, 4, and 16 to compare them side-by-side. Position the pixel inspector over an area that showcases the effect dramatically; for example, a very skinny triangle corner. Explain why these results are observed.</b><br><br>

The edges of the triangle account for the fact that they are next while empty space and slowly smoothen out as we increase the samle rate becoming lighter in tone and melting into the picture to remove the harsh effect posed by the jaggies in the lower sample rates.<br><br>

<div class="row">
  <div class="column">
    <figure>
  <p><img src="image/part2_sample_1.png" style="width:280px">
    <figcaption>Test 4, 1 sample per pixel</figcaption>
</figure>
  </div>
  <div class="column">
    <figure>
  <p><img src="image/part2_sample_4.png" style="width:280px">
    <figcaption>Test 4, 4 sample per pixel</figcaption>
</figure>
  </div>
  <div class="column">
    <figure>
  <p><img src="image/part2_sample_16.png" style="width:280px">
    <figcaption>Test 4, 16 sample per pixel</figcaption>
</figure>
</div>
</div>
<br><br>
<h2 id="3">Part 3: Transforms</h2>

<b>Create an updated version of svg/transforms/robot.svg with cubeman doing something more interesting, like waving or running. Feel free to change his colors or proportions to suit your creativity. Save your svg file as my_robot.svg in your docs/ directory and show a png screenshot of your rendered drawing in your write-up. Explain what you were trying to do with cubeman in words.</b><br><br>

The robot is waving and holding its hip, this was done with simple rotations and repositioning of the arms. See pictures below.<br><br>

<b>Extra credit</b> <br><br>
Pressing '.' will rotate the view in the GUI. See rotated robot below. <br><br>

<div class="row">
  <div class="column">
    <figure>
  <p><img src="image/part3.png" style="width:300px">
    <figcaption>waving robot</figcaption>
</figure>
  </div>
  <div class="column">
    <figure>
  <p><img src="image/part3_e.png" style="width:300px">
    <figcaption>rotated waving robot</figcaption>
</figure>
  </div>
</div>

<h2 id="4">Part 4: Barycentric coordinates</h2>
<h3> Pixel sampling</h3>
<b>Explain barycentric coordinates in your own words and use an image to aid you in your explanation. One idea is to use a svg file that plots a single triangle with one red, one green, and one blue vertex, which should produce a smoothly blended color triangle.</b><br><br>
Using barycentric coordinates means that values are determined by their relative distance of a point to each of the given vertices, as you can see in the image below we can break a triangle based on the position of a given point.<br><br>
<h3> Show a png screenshot of svg/basic/test7.svg with default viewing parameters and sample rate 1. If you make any additional images with color gradients, include them.</h3>

<div class="row">
  <div class="column">
    <figure>
  <p><img src="image/part4.png" style="width:300px">
    <figcaption>Test 7, 1 sample per pixel</figcaption>
</figure>
  </div>
  <div class="column">
    <figure>
  <p><img src="image/part4_e.png" style="width:600px">
    <figcaption>Example</figcaption>
</figure>
  </div>
</div>


<h2 id="5">Part 5 "Pixel sampling" for texture mapping</h2>
<h3> Pixel sampling</h3>
<b>Explain pixel sampling in your own words and describe how you implemented it to perform texture mapping. Briefly discuss the two different pixel sampling methods, nearest and bilinear.</b><br><br>

Pixel sampling is to find the pixel colour from the texel space to draw on a pixel space. It can be divided into 1:1 mapping (the ideal case), upsampling and downsampling. For magnification and minification, we implement interpolation functions to fill up the pixel space. <br><br>

<b>Nearest sampling</b> <br>
We first find the nearest mipmap level, then the nearest texel center is sampled to get the pixel color. Using mipmapping can improve texture memory but this cannot avoid box-like artifacts in texture magnification. <br><br>
<b>Bilinear sampling</b><br>
 We implement linear interpolation function (lerp) three times to find the interpolated colour of a pixel. The pixel colour depends on the four nearest texels to the pixel. This provides a more smooth interpolation compared to nearest interpolation but still can behave some artifacts. <br><br>

<h3> Results</h3>
<b>Check out the svg files in the svg/texmap/ directory. Use the pixel inspector to find a good example of where bilinear sampling clearly defeats nearest sampling. Show and compare four png screenshots using nearest sampling at 1 sample per pixel, nearest sampling at 16 samples per pixel, bilinear sampling at 1 sample per pixel, and bilinear sampling at 16 samples per pixel.</b>

<div class="row">
  <div class="column">
    <figure>
  <p><img src="image/part5_nearest_1.png" style="width:300px">
    <figcaption>nearest sampling, 1 sample per pixel</figcaption>
</figure>
  </div>
  <div class="column">
    <figure>
  <p><img src="image/part5_nearest_16.png" style="width:300px">
    <figcaption>nearest sampling, 16 sample per pixel</figcaption>
</figure>
  </div>
</div>
<div class="row">
  <div class="column">
    <figure>
  <p><img src="image/part5_bilinear_1.png" style="width:300px">
    <figcaption>bilinear sampling, 1 sample per pixel</figcaption>
</figure>
  </div>
  <div class="column">
    <figure>
  <p><img src="image/part5_bilinear_16.png" style="width:300px">
    <figcaption>bilinear sampling, 16 sample per pixel</figcaption>
</figure>
  </div>
</div>

<h3> Difference</h3>
<b>Comment on the relative differences. Discuss when there will be a large difference between the two methods and why.</b><p>

For the svg sampled at one sample per pixel rate, both nearest sampling and bilinear sampling behaves a box-like artifacts, but the bilinear sampling is smoother. For the 16 samples per pixel, both sampling stretegies is smoother compared to the 1 sample per pixel case, and there is hardly visual artifacts for the textured image. However, a closer look at the pixel inspector, we can still see that the bilinear sampling behaves better. <p>

The region in texture with uniform colour is not affected much from the sampling mechanism, the region with high frequencies is mostly affected by the sampling size and function. 


<h2 id="6">Part 6 "Level sampling" with mipmaps for texture mapping</h2>
<h3> Level sampling</h3>
<b>Explain level sampling in your own words and describe how you implemented it for texture mapping.</b><p>
For a complex scene, we may need different resolution of texture with a higher resolution in the objects near us, and a low resolution for faraway objects. If we apply uniform texture sampling, it will either cause blur (for near objects) or aliasing (for farther objects) or both. <p>
Using level sampling, with a reduced level of detail for farther objects with a lower sample rate, can avoid the forementioned problem. To achieve this, for each barycentric coordinates, we compute the level of detail (D) the pixel required.

<h3> Tradeoffs</h3>
<b>You can now adjust your sampling technique by selecting pixel sampling, level sampling, or the number of samples per pixel. Describe the tradeoffs between speed, memory usage, and antialiasing power between the three various techniques.</b><p>

For total of 6 combinations of the texture filtering algorithm, the quickest combination is nearest + level 0, which renders a huge aliasing. Bilinear interpolation + linear interpolation for mipmap level sampling renders the best image. It takes much longer to compute because we need to find the derivatives three times for one pixel to get the level of mipmap. The nearest level of mipmap can cause blur but also a smooth in texture mapping. Bilinear sample also remove the box artifacts compared with nearest sample. <p>
Speed: L_0>L_nearest, P_nearest>P_linear. <p>
Memory use: L_nearest>L_0 because need to store mipmap.<p>
Antialiasing power: L_nearest>L_0, P_linear>P_nearest. <p>

<h3> Results</h3>
<b>Using a png file you find yourself, show us four versions of the image, using the combinations of L_ZERO and P_NEAREST, L_ZERO and P_LINEAR, L_NEAREST and P_NEAREST, as well as L_NEAREST and P_LINEAR.</b><p>
<div class="row">
  <div class="column">
    <figure>
  <p><img src="image/L_zero_P_nearest.png" style="width:300px">
    <figcaption>L_0, P_nearest</figcaption>
</figure>
  </div>
  <div class="column">
    <figure>
  <p><img src="image/L_zero_P_bilinear.png" style="width:300px">
    <figcaption>L_0, P_linear</figcaption>
</figure>
  </div>
</div>
<div class="row">
  <div class="column">
    <figure>
  <p><img src="image/L_near_P_near.png" style="width:300px">
    <figcaption>L_nearest, P_nearest</figcaption>
</figure>
  </div>
  <div class="column">
    <figure>
  <p><img src="image/L_near_P_bilinear.png" style="width:300px">
    <figcaption>L_nearest, P_linear</figcaption>
</figure>
  </div>
</div>


<h3> Extra credit</h3>
<b>Extra credit: If you implemented any extra filtering methods, describe them and show comparisons between your results with the other above methods.</b><p>
NA.




</ul>

</div>

</body>
</html>
